<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whitepaper | GatewayAgente</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d1117;
            --paper-bg: rgba(22, 27, 34, 0.8);
            --border-color: rgba(255, 255, 255, 0.1);
            --primary: #8a2be2;
            --secondary: #00d2ff;
            --text-main: #e6edf3;
            --text-muted: #8b949e;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #0d1117;
            background-image: 
                radial-gradient(circle at 15% 50%, rgba(138, 43, 226, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 85% 30%, rgba(0, 210, 255, 0.08) 0%, transparent 50%);
            color: var(--text-main);
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        .navbar {
            background: rgba(13, 17, 23, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            padding: 15px 40px;
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .navbar .logo {
            font-size: 20px;
            font-weight: 800;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-decoration: none;
        }

        .navbar a.btn-back {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 14px;
            font-weight: 600;
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .navbar a.btn-back:hover {
            color: #fff;
            border-color: var(--secondary);
        }

        .container {
            max-width: 800px;
            margin: 60px auto;
            padding: 0 20px;
        }

        .paper-header {
            text-align: center;
            margin-bottom: 60px;
        }

        .paper-header h1 {
            font-size: 36px;
            margin-bottom: 15px;
            letter-spacing: -1px;
        }

        .paper-header .subtitle {
            font-size: 18px;
            color: var(--text-muted);
            font-weight: 400;
        }

        .paper-content {
            background: var(--paper-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 50px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        h2 {
            color: var(--secondary);
            font-size: 24px;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(0, 210, 255, 0.2);
            padding-bottom: 10px;
        }

        h2::before {
            content: ">> ";
            color: var(--primary);
            font-family: 'JetBrains Mono', monospace;
        }

        h3 {
            color: #fff;
            font-size: 18px;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        p {
            color: #c9d1d9;
            font-size: 16px;
            margin-bottom: 20px;
            text-align: justify;
        }

        ul {
            color: #c9d1d9;
            margin-bottom: 20px;
            padding-left: 20px;
        }

        li {
            margin-bottom: 10px;
        }

        strong {
            color: #fff;
            font-weight: 600;
        }

        .highlight-box {
            background: rgba(138, 43, 226, 0.1);
            border-left: 4px solid var(--primary);
            padding: 20px;
            border-radius: 0 8px 8px 0;
            margin: 30px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .paper-content { padding: 30px 20px; }
            .paper-header h1 { font-size: 28px; }
            .navbar { padding: 15px 20px; }
        }
    </style>
</head>
<body>

    <nav class="navbar">
        <a href="../" class="logo">GatewayAgente</a>
        <a href="../" class="btn-back">← Back to App</a>
    </nav>

    <div class="container">
        <div class="paper-header">
            <h1>WHITEPAPER: GatewayAgente</h1>
            <div class="subtitle">Crypto-Economic Infrastructure and Decentralized Firewall for Trading Agents in DeFi</div>
        </div>

        <div class="paper-content">
            
            <h2>1. Executive Summary</h2>
            <p>Crypto automation is stuck in a paradox. Serious capital does not trust bots, copy trading or “DeFi managers” because there is always someone with discretionary power over withdrawals, risk and reporting. At the same time, the few people who actually have winning strategies do not want to expose their code, nor take on the regulatory and operational burden of managing other people’s money.</p>
            <p><strong>GatewayAgente</strong> breaks this deadlock by turning any trading agent into a <strong>closed‑mandate decentralized fund</strong>. Capital is held in a non‑custodial Smart Vault that enforces absolute loss limits (Hard Floor) and only executes trades within a DAO‑curated whitelist of tokens, swaps and protocols. The strategy lives inside a black‑box container identified by a cryptographic hash, is validated by a decentralized backtesting network (Proof of Backtest), and earns on‑chain performance fees without ever revealing its code or alpha.</p>
            <p>The result is new financial infrastructure: investors get institutional‑grade downside protection and predictable mandates; developers run capital like a fund manager, at global scale, with no custody, no backoffice and no forced disclosure. The chain enforces, line by line, what can and cannot happen to the money.</p>

            <h2>2. The Problem: Bots, Copy Trading and the Trust Fallacy</h2>
            <p>The dominant automation models today all rely on implicit trust:</p>
            <ul>
                <li>Bots that trade from custodial exchange accounts or have direct access to the investor’s key.</li>
                <li>Copy/mirror trading platforms where users do not control risk engines or order books.</li>
                <li>DeFi vaults where strategies are upgradable, legible on-chain and controlled by opaque multisigs.</li>
            </ul>
            <p>This creates a bad game for both sides.</p>
            <p><strong>For investors:</strong></p>
            <ul>
                <li>There is always an actor with discretionary power: exchange, bot operator, multisig signer.</li>
                <li>Loss limits are at best promises: stop‑losses and circuit breakers are off‑book logic, not protocol‑level guarantees.</li>
                <li>Track records are easy to fake or cherry‑pick with backtests and selective disclosure.</li>
            </ul>
            <p><strong>For strategy developers:</strong></p>
            <ul>
                <li>Exposing code for listing or “security review” usually means giving away alpha.</li>
                <li>Running other people’s capital via traditional structures means regulation, compliance, and operational overhead.</li>
                <li>Even when they succeed, their track record lives inside centralized databases, not as a portable, verifiable on‑chain asset.</li>
            </ul>
            <p>What is missing is not “another bot platform”. What is missing is infrastructure that makes <strong>theft impossible by design</strong>, <strong>track‑record fraud pointless</strong>, and <strong>consistent behavior directly rewarded</strong> at protocol level.</p>

            <h2>3. Core Architecture: Closed‑Mandate Vault + Black‑Box Agent</h2>
            
            <p>GatewayAgente is built on a radical separation of concerns: capital never sees the code, and code never touches the capital.</p>

            <h3>3.1. The Vault (the Hand)</h3>
            <p>The Gateway Vault is a non‑custodial smart contract that:</p>
            <ul>
                <li>Holds the investor’s assets.</li>
                <li>Applies a <strong>closed mandate</strong>: no withdrawals are allowed before a predefined time and/or return target is reached.</li>
                <li>Enforces, on‑chain, an absolute Hard Floor on losses: if a trade would push the vault below this floor, it cannot execute.</li>
                <li>Routes all trades through whitelisted adapters for specific DEXs and protocols pre‑approved by the DAO.</li>
            </ul>
            <p>In practice, the Vault behaves like a closed‑end fund encoded in Solidity: once the agent, time horizon, safety floor and investable universe are set, nobody — not the protocol, not the developer, not even the investor — can violate those rules. Non‑conforming transactions simply revert.</p>

            <h3>3.2. The Agent (the Brain)</h3>
            <p>The Agent is an immutable container that:</p>
            <ul>
                <li>Observes markets off‑chain, applies the developer’s logic and emits only highly constrained trade <em>intents</em>.</li>
                <li>Never holds withdrawal keys, never touches the vault directly and never chooses arbitrary destinations — it can only suggest swaps within a predefined sandbox.</li>
                <li>Is identified on‑chain by:
                    <ul>
                        <li><strong>H</strong>: the hash of its container image; and</li>
                        <li><strong>K</strong>: a public key used to sign intents.</li>
                    </ul>
                </li>
            </ul>
            <p>The channel between Brain and Hand is a single, narrow function with a few parameters that the Vault can fully validate and locally simulate before accepting or rejecting.</p>

            <div class="highlight-box">
                [Execution Flow]<br>
                1. Agent → Produces an Intent with constrained parameters<br>
                2. Agent → Signs the Intent with key K<br>
                3. Vault → Verifies signature, mandate, Hard Floor and token/protocol whitelist<br>
                4. Vault → Routes to the corresponding DEX Adapter and executes if all checks pass
            </div>

            <h2>4. Closed Mandate: Time, Target, No Early Withdrawals</h2>
            <p>Every Vault is born with an explicit mandate that defines the rules of the game from day zero to settlement.</p>

            <h3>4.1. No early withdrawals</h3>
            <p>In GatewayAgente:</p>
            <ul>
                <li>The <code>withdraw</code> function is only enabled when at least one of the following is true:
                    <ul>
                        <li><code>block.timestamp &gt;= endTimestamp</code> (the mandate’s time horizon has ended); or</li>
                        <li><code>NAV &gt;= targetNAV</code> (the vault has reached its return target).</li>
                    </ul>
                </li>
                <li>Before that, no partial or full withdrawals are possible.</li>
                <li>The vault owner can call <code>stopStrategy()</code> at any time to pause new trades while keeping funds locked until the mandate ends.</li>
            </ul>
            <p>This removes two common failure modes: liquidity runs triggered by fear during drawdowns, and performance‑fee gaming via opportunistic redemptions right after a lucky spike.</p>

            <h3>4.2. Hard Floor: absolute loss limit</h3>
            <p>On top of the temporal/economic mandate, the Vault stores a <strong>Hard Floor</strong> in absolute value:</p>
            <ul>
                <li>If an investor allocates, for example, 10,000 units of value with a maximum loss of 1,500, the contract fixes a floor at 8,500.</li>
                <li>Before every trade, the Vault:
                    <ul>
                        <li>queries price oracles to mark all positions to market,</li>
                        <li>estimates post‑trade NAV, and</li>
                        <li>reverts any operation that would push NAV below 8,500.</li>
                    </ul>
                </li>
            </ul>
            <p>Loss limits stop being a moral commitment and become a mathematical property of the system.</p>

            <h2>5. Strategy Drawdown: Room to Play Without Breaking</h2>
            <p>No serious strategy exists without drawdowns. The right question is not “can we avoid losses?” but “how much pain is acceptable before we define ruin?”.</p>
            <p>GatewayAgente separates two layers of protection:</p>
            <ul>
                <li><strong>Investor Hard Floor:</strong> a non‑negotiable absolute loss limit encoded in the Vault.</li>
                <li><strong>Strategy drawdown budget (<code>strategyDrawdownBudget</code>):</strong> a margin declared by the agent, describing how much it expects to fluctuate below local peaks while still operating correctly.</li>
            </ul>
            <p>During Proof of Backtest:</p>
            <ul>
                <li>The developer declares the drawdown budget needed for the strategy to function over a given horizon.</li>
                <li>The backtesting network simulates the container across different regimes, enforcing both the Hard Floor and the internal budget.</li>
                <li>Only combinations where the strategy can operate without hugging the floor or systematically blowing through its own budget are approved.</li>
            </ul>
            <p>On live capital, the Vault can track local peaks, realized drawdowns and automatically pause a strategy that drifts outside its tested envelope.</p>

            <h2>6. Immutable Agents: Container Hash as Strategy Identity</h2>
            <p>The mechanism that turns “a set of scripts” into a reusable on‑chain asset is the notion of the agent as an immutable artifact.</p>

            <h3>6.1. Formal definition</h3>
            <p>An agent <em>A</em> in GatewayAgente is defined by the pair (<em>H</em>, <em>K</em>):</p>
            <ul>
                <li><strong>H:</strong> a cryptographic hash (e.g. SHA‑256) of the container image holding the strategy logic.</li>
                <li><strong>K:</strong> a public key used by the container to sign intents.</li>
            </ul>
            <p>On‑chain, the protocol does not need to know anything about the code. It only needs to ensure that:</p>
            <ul>
                <li>every accepted intent is signed by <em>K</em>; and</li>
                <li>the pair (<em>H</em>, <em>K</em>) has been pre‑approved by the backtesting network for a specific risk profile.</li>
            </ul>
            <p>Any code change — from minor tweaks to full rewrites — produces a new hash <em>H’</em>, and therefore a new agent. There is no such thing as a “silent update” under the same identity.</p>

            <h3>6.2. Minimal container interface</h3>
            <p>Operationally, every agent container exposes a minimal, standard interface, for example:</p>
            <ul>
                <li><strong>Input:</strong> a canonical market snapshot (prices, liquidity, current vault positions, timestamp, etc.).</li>
                <li><strong>Output:</strong> a trade <code>Intent</code> with limited fields: <code>tokenIn</code>, <code>tokenOut</code>, <code>amountIn</code>, <code>minAmountOut</code>, <code>deadline</code> and optionally a route hint.</li>
            </ul>
            <p>Inside the black box, the developer is free to use any blend of models, heuristics or signals. Outside, the protocol sees a simple object that can be checked against vault limits and the global whitelist of assets and protocols.</p>

            <h2>7. Proof of Backtest: Decentralized Black‑Box Validation</h2>
            
            <p>To prevent both strategy theft and marketing games, agent approval in GatewayAgente does not rely on trust in a single entity, but on a decentralized, reproducible backtesting process.</p>

            <h3>7.1. The backtesting network (DON)</h3>
            <p>The protocol defines a network of specialized simulation nodes — a backtesting DON — which:</p>
            <ul>
                <li>Receive the agent container (or equivalent artifact) plus declared risk metadata (minimum horizon, drawdown budget, supported asset classes).</li>
                <li>Use standardized historical datasets covering different volatility and stress regimes.</li>
                <li>Run the container as a black box, feeding inputs and recording the sequence of emitted intents.</li>
            </ul>
            <p>Each node then applies a local simulation of the Vault:</p>
            <ul>
                <li>enforcing the Hard Floor and the closed mandate;</li>
                <li>enforcing token, pair and protocol whitelists;</li>
                <li>computing time series of NAV, PnL, drawdown and auxiliary indicators.</li>
            </ul>

            <h3>7.2. Approval consensus</h3>
            <p>If, after simulation:</p>
            <ul>
                <li>the agent consistently respects the Hard Floor;</li>
                <li>operates within its declared drawdown budget; and</li>
                <li>never attempts to use forbidden assets or routes,</li>
            </ul>
            <p>each node issues an approval vote. Once a quorum is reached, the DON produces an aggregated signature over a summary message (e.g. “agent (H, K) approved for asset classes X, Y, Z with horizon T and drawdown budget D”).</p>
            <p>This signature is submitted to an on‑chain <code>AgentRegistry</code> contract, which verifies the cryptography, checks quorum and governance rules, and records (<em>H</em>, <em>K</em>) as an approved agent with its risk profile. From that point forward, any vault is free to opt into that agent — within the approved bounds — without having to trust marketing slides or unverifiable track records.</p>

            <h3>7.3. Data requirements and vault simulation for backtesting nodes</h3>
            <p>Running a backtesting consensus node in GatewayAgente is not just about providing CPU cycles. Nodes must be able to reproduce, as faithfully as possible, how the agent would behave if it were trading on-chain.</p>
            <p>To be eligible for random committee selection, a node must:</p>
            <ul>
                <li>Maintain a minimum historical dataset of market data:
                    <ul>
                        <li>Fetched from one or more <strong>official data providers</strong> specified by the protocol (e.g. canonical APIs or standardized dumps).</li>
                        <li>Using the same sources, formats and resolutions (prices, liquidity, volume, etc.) that inform on-chain oracle feeds.</li>
                    </ul>
                </li>
                <li>Run the <strong>canonical Vault simulator</strong>, which replicates:
                    <ul>
                        <li>Hard Floor rules and mandate logic (time/target constraints).</li>
                        <li>Token/pair/protocol whitelists.</li>
                        <li>Adapter execution semantics (fees, slippage assumptions and rounding).</li>
                    </ul>
                </li>
            </ul>
            <p>For each randomly assigned window, a node:</p>
            <ul>
                <li>Loads the relevant slice of the historical dataset for that period.</li>
                <li>Feeds the agent container with canonical market + vault state snapshots.</li>
                <li>Captures the sequence of emitted Intents and passes them through the Vault simulator, exactly as if they were real on-chain transactions:
                    <ul>
                        <li>verifying signatures from key K,</li>
                        <li>enforcing Hard Floor, mandate and whitelists,</li>
                        <li>executing trades and updating NAV, PnL and drawdown locally.</li>
                    </ul>
                </li>
            </ul>
            <p>In other words, backtesting nodes do not just “look at signals”; they emulate the full lifecycle of the strategy interacting with a Vault under standardized market data.</p>

            <h3>7.4. Honest disagreement vs. misbehavior</h3>
            <p>Backtesting committees are designed to tolerate <strong>honest disagreement</strong>. A node may vote against approval even if most others vote in favor, simply because the random windows it was assigned produced worse outcomes for the strategy. That is not misbehavior; it is precisely the kind of diversity the protocol wants.</p>
            <p>Slashing and penalties are therefore reserved for <strong>technical faults or provable dishonesty</strong>, such as:</p>
            <ul>
                <li>Submitting votes that are <em>cryptographically inconsistent</em> with the container and data actually tested (e.g. signing an approval without running the required simulations).</li>
                <li>Systematic deviation from canonical data or simulator rules that can be demonstrated by cross-checking with other honest nodes.</li>
                <li>Protocol-level violations (double-signing contradictory results for the same agent and test parameters).</li>
            </ul>
            <p>A node that honestly reports “this agent lost money or stressed its drawdown budget in my sample” should <strong>not</strong> be punished for disagreeing with the majority. Instead, the aggregation logic focuses on whether the agent’s behavior is acceptable across a wide distribution of random tests, not on forcing all nodes to agree on a single number.</p>

            <h2>8. DAO Governance: Risk Curation and Protocol Evolution</h2>
            <p>GatewayAgente is designed to gradually hand over risk and integration decisions to a Decentralized Autonomous Organization (DAO). The DAO acts as an on‑chain risk committee, defining the action space available to vaults and agents.</p>

            <h3>8.1. Global whitelist of tokens, swaps and protocols</h3>
            <p>The DAO controls a global permission registry that specifies:</p>
            <ul>
                <li>Which tokens are investable, grouped into risk categories (blue‑chips, audited stablecoins, long‑tail, experimental).</li>
                <li>Which token pairs and swap routes are allowed (e.g. WBTC ↔ USDC on a specific DEX; outright bans on illiquid meme‑coins).</li>
                <li>Which DEXs, bridges and liquidity protocols may be used by vaults.</li>
            </ul>
            <p>No vault may hold exposure to an asset that has not been approved. If a token is later removed — for example, due to a security incident — vaults are only allowed to unwind or reduce exposure, never to increase it. The whitelist effectively acts as a collective on‑chain risk officer for the entire ecosystem.</p>

            <h3>8.2. Global risk parameters</h3>
            <p>Beyond whitelists, the DAO configures system‑wide risk parameters such as:</p>
            <ul>
                <li>Allowed Hard Floor ranges for public products.</li>
                <li>Maximum leverage or synthetic exposure (if and when derivatives are supported).</li>
                <li>Default policies for slippage, relative order size and max trade frequency.</li>
            </ul>

            <h3>8.3. Backtesting network and validator governance</h3>
            <p>The DAO is also responsible for:</p>
            <ul>
                <li>Defining eligibility criteria for backtesting nodes (minimum stake, technical requirements, performance history).</li>
                <li>Setting rewards for honest simulation work and slashing rules for provable fraud or negligence.</li>
                <li>Tuning committee sizes and quorums for agent approval.</li>
            </ul>

            <h2>9. On‑Chain Leaderboard and Developer Incentives</h2>
            <p>For GatewayAgente to become the default infrastructure for serious strategists, it must be the most rewarding place to publish a strategy. That means transparent reputation and a business model that pays for consistency, not just for volatility.</p>

            <h3>9.1. Real‑PnL leaderboard</h3>
            <p>Because every vault operation is on‑chain, GatewayAgente can support a public, tamper‑proof leaderboard. For each agent (<em>H</em>, <em>K</em>), analytics can display:</p>
            <ul>
                <li>Total realized return across closed mandates.</li>
                <li>Maximum realized drawdown per mandate.</li>
                <li>Number of completed mandates.</li>
                <li>Average and peak AUM (sum of all vaults using that agent).</li>
                <li>Success rate: how many mandates hit their return targets versus just expiring on time.</li>
            </ul>
            <p>The primary leaderboard only counts completed mandates. Backtests and live‑but‑unfinished vaults can be shown in separate views, but never drive the main ranking.</p>

            <h3>9.2. On‑chain performance fees: developers as decentralized fund managers</h3>
            <p>Every vault run by an agent charges a performance fee on profits above the high‑water mark, set at vault creation. At the end of the mandate:</p>
            <ul>
                <li>The contract computes net profit versus the highest historical NAV.</li>
                <li>Applies the agreed performance fee.</li>
                <li>Automatically sends the developer’s share to a reward address linked to (<em>H</em>, <em>K</em>), and optionally a share to the DAO treasury.</li>
            </ul>
            <p>For a developer, each approved container effectively becomes a fund: any allocator can spin up a vault with that agent, within its risk envelope, and performance fees flow directly and programmatically.</p>

            <h3>9.3. Developer‑owned vaults: skin in the game</h3>
            <p>GatewayAgente explicitly encourages strategy creators to allocate their own capital into vaults powered by their agents. This creates a visible <strong>skin in the game</strong> signal:</p>
            <ul>
                <li>Vaults where the agent’s creator holds a meaningful stake are highlighted (badges, filters, separate views).</li>
                <li>The DAO may choose to grant slightly better protocol‑fee terms to such vaults, recognizing the improved alignment.</li>
            </ul>
            <p>Leaderboards can show how much of an agent’s total AUM is creator‑owned, and how those co‑invested mandates have performed.</p>

            <h2>10. Comparison with Traditional Models</h2>
            <p>Summarized:</p>
            <ul>
                <li><strong>Bots / CEX copy trading:</strong> centralized custody, off‑book risk controls, private and mutable track records.</li>
                <li><strong>Traditional DeFi vaults:</strong> upgradeable contracts, visible strategies, multisig governance.</li>
                <li><strong>GatewayAgente:</strong> immutable Smart Vaults, closed mandates, absolute Hard Floors, black‑box agents and fully on‑chain performance history.</li>
            </ul>

            <h2>11. Roadmap</h2>
            <p>The initial roadmap is deliberately pragmatic:</p>
            <ul>
                <li><strong>Phase 1:</strong> Deploy core contracts on an established EVM L2; launch a first closed‑mandate vault type; onboard 2–3 internal agents; expose a basic leaderboard.</li>
                <li><strong>Phase 2:</strong> Open container submission to external developers; launch a minimal backtesting DON; bootstrap a DAO for token/route/protocol whitelisting.</li>
                <li><strong>Phase 3:</strong> Add optional TEEs and stronger attestation paths, support multiple L2s, and design dedicated institutional products, depending on traction.</li>
            </ul>
            <p>The target is unambiguous: to make GatewayAgente the default way to turn strategies into decentralized funds — with mathematical safety, clean incentives and reputations written directly on-chain.</p>

        </div>
    </div>

</body>
</html>
